<~
-- A number is divisible by 3 if and only if the sum of its digits is divisible by 3
-- We add a single starting state (Nothing) to avoid accepting the empty string.
-- The state we are in is the (running total % 3)
-- So, add the (running total % 3) to the current digit, then (% 3) again
by3 :: DFA (Maybe Mod3) Digits
by3 = DFA { delta = Just . toEnum . (`mod` 3) . delta'
          , q0    = Nothing
          , fs    = singleton (Just IsZero)
          } where delta' (q, digit) = q' + digit'
                    where q'     = fromEnum (fromMaybe IsZero q)
                          digit' = fromEnum digit


-- A regular expression to match the language of the divisibleBy5 DFA
-- TODO checkme
-- [0-9]*[0+5]
-- (((((((((((1+2)+3)+4)+5)+6)+7)+8)+9)+0))â‹†.(0+5))
div5 :: RE.RegExp Digits
div5 = RE.closure
        ( RE.literal One   RE.+
          RE.literal Two   RE.+
          RE.literal Three RE.+
          RE.literal Four  RE.+

          RE.literal Six   RE.+
          RE.literal Five  RE.+

          RE.literal Seven RE.+
          RE.literal Eight RE.+
          RE.literal Nine  RE.+
          RE.literal Zero
        ) RE.* (RE.literal Zero RE.+ RE.literal Five)
~>
toString : (x : int) -> string {
  if (x == 1)  { return "1"; }
  if (x == 2)  { return "2"; }
  if (x == 3)  { return "3"; }
  if (x == 4)  { return "4"; }
  if (x == 5)  { return "5"; }
  if (x == 6)  { return "6"; }
  if (x == 7)  { return "7"; }
  if (x == 8)  { return "8"; }
  if (x == 9)  { return "9"; }
  if (x == 10) { return "10"; }
  if (x == 11) { return "11"; }
  if (x == 12) { return "12"; }
  if (x == 13) { return "13"; }
  if (x == 14) { return "14"; }
  if (x == 15) { return "15"; }
  if (x == 16) { return "16"; }
  if (x == 17) { return "17"; }
  if (x == 18) { return "18"; }
  if (x == 19) { return "19"; }
  return "";
}

main : -> int {
  int i;
  string num;
  regexp numeric;
  regexp by5;
  dfa by3;
  by3 = {
   states : 5
   alphabet : ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
   start : 0
   final : [1]
   transitions : [ (0 '0' 1), (0 '1' 2), (0 '2' 3), (0 '3' 1), (0 '4' 2), (0 '5' 3), (0 '6' 1), (0 '7' 2), (0 '8' 3), (0 '9' 1)
                 , (1 '0' 1), (1 '1' 2), (1 '2' 3), (1 '3' 1), (1 '4' 2), (1 '5' 3), (1 '6' 1), (1 '7' 2), (1 '8' 3), (1 '9' 1)
                 , (2 '0' 2), (2 '1' 3), (2 '2' 1), (2 '3' 2), (2 '4' 3), (2 '5' 1), (2 '6' 2), (2 '7' 3), (2 '8' 1), (2 '9' 2)
                 , (3 '0' 3), (3 '1' 1), (3 '2' 2), (3 '3' 3), (3 '4' 1), (3 '5' 2), (3 '6' 3), (3 '7' 1), (3 '8' 2), (3 '9' 3)
                 ]
  };
  numeric = (lit '0' | lit '1' | lit '2' | lit '3' | lit '4' | lit '5' | lit '6' | lit '7' | lit '8' | lit '9') **;
  by5 = numeric ^ (lit '0' | lit '5');
  if (by3 accepts "33") {
     print(1);
  }

  if (by3 accepts "66") {
     print(1);
  } else {
    print(0);
  }

  for i = 1; i <= 19; i = i + 1 {
    num = toString(i);
    if (by3 accepts num) {
      printf("fizz");
    } else {
      if (by5 matches num) {
        printf("buzz");
      } else {
        print(i);
      }
    }
    printf("\n");
  }

  return 0;
}
